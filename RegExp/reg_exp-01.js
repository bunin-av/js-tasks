// ## Шаблонизатор

// Необходимо написать функцию, которая принимает строковый шаблон и объект параметров,
// и возвращает результат применения данных к этому шаблону.
// Для решения задачи нужно использовать регулярное выражение с запоминающими скобками и метод replace у строки.
// В качестве тренировки можно сделать это задание без регулярного выражения.

function format(string, params) {
  const rex = /\${([\w$]+)}/g
  return string.replace(rex, (_, ...props) => params[props[0]])
}

// console.log(format('Hello, ${user}! Your age is ${age}.', {user: 'Bob', age: 10}))


// ## Проверка пароля

// Необходимо написать регулярное выражение, которое при вызове test на строке будет давать false,
// если в строке есть символы отличные от латинских, цифр, подчеркивания и знака $.

const myRegExp = /^[\w$]+$/

// console.log(myRegExp.test('привет ')) // false


// ## Деление строки

// Необходимо создать массив на основе строки, где раздилителем будут символы . , ; или пробелы (подряд идущие пробелы считаюся за один)

const myRExp = /[ .,;]+/
// console.log('foo    bla.bar,gd;4'.split(myRExp)) // ['foo', 'bla', 'bar', 'gd', '4']


// ## Итератор на основе строки

// Необходимо создать итератор на основе исходной строки

const myRex = /"(\w)": (\d+|".*")/g

// [['"a": 1', 'a', '1'], ['"b": "2"', 'b', '"2"']]
//   console.log([...'{"a": 3, "b": "@"}'.matchAll(myRex)]);

// ## Сжатие строки

// Необходимо написать регулярное выражение, которое бы удаляла из строки любые дублирования подстрок из 1-го, 2-х или 3-х символов, которые идут подряд.
// Подсказка: нужно использовать скобочные группы и обратные ссылки.

let re = /(\w{1,3})\1+/g
// console.log('abababbbabcabc'.replace(re, '$1')) // == 'abbabc'


// ## Нахождение скобочных групп

// Необходимо написать регулярное выражение, которое бы находило содержимое скобочных групп.
// Внутри скобочной группы может быть экранированный символ группы.
// "foo"
// 'bar\''
// `b\`la`
  // (['"`])(\\.|[^\\'"`])*\1

let rexp = /(?<=“)(\\.|[^\\'"`”])*(?=”)|(?<=‘)(\\.|[^\\'"`’])*(?=’)/g


// console.log(rexp.exec("‘Hello “foo \\\\” bar\\\\\\\\” baz “ban”’"))
console.log(rexp.exec('"bar" "foo"'))
console.log(rexp.exec('"bar" "foo"'))
// console.log("`b`la` 'ddo'".replace(/(['"`‘])(.*?)\1/g, '$2'))
// rexp.exec('bar\'')



// ## Поменять ключи и значения местами
//

const str = `{
  "foo": 1,
  10: 'baz',
  bla: true,
  ban: {a: 1}
}`;

let r = /((['"]?)\b[\w$]+\b\2): ([^\n,]+)(,?)$/gm
// str.replace(r, (str,$1,_,$2,$3)=> `${$2}: ${$1}${$3}`)

let r2 = /((['"]?)\b[\w$]+\b\2): ([^\n,]+)(?=,)?/gm
// str.replace(r, (str,$1,_,$2)=> `${$2}: ${$1}`)

// == `{
//   1: "foo",
//   baz: 10,
//   true: 'bla',
//   '{a: 1}': 'ban'
// }`;


// ## Парсинг XML


const s = `
<div bla="foo">
  <div class=ban checked data-foo="baz bar"></div>
</div>
`;

let reg = /(?<=<)(\w+)\s*(.*?)(?=>)/gi
reg.exec(s); // ['div bla="foo"', 'div', 'bla="foo"'];
reg.exec(s); // ['div class=ban checked data-foo="baz"', 'div', 'class=ban', 'checked', 'data-foo="baz bar"'];
